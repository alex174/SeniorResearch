<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Tue Feb 19 12:54:54 CET 2002 -->
<TITLE>
: Class  BFagent
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/BFagent.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../asm/BarChart.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../asm/BFCast.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="BFagent.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
asm</FONT>
<BR>
Class  BFagent</H2>
<PRE>
<A HREF="../asm/Agent.html">asm.Agent</A>
  |
  +--<B>asm.BFagent</B>
</PRE>
<HR>
<DL>
<DT>public class <B>BFagent</B><DT>extends <A HREF="../asm/Agent.html">Agent</A></DL>

<P>
<p>Title: BFgent</p>
 <p>Description: El BFagent--"bitstring forecasting agent" es la piezacentral
 del modelo de ASM. El agente compite en una bolsa de valores, él compra, vende.
 Decide comprar o vender haciendo predicciones sobre lo que es probable que el
 precio de la acción haga en el futuro. Para hacer las predicciones, guarda
 una lista grande de forecasters disponible, y cada forecaster hace una
 predicción del precio. Estas previsiones que se crean en la subclase de BFCast
 son entidades bastante sofisticadas, ellos pueden supervisar muchas condiciones
 diferentes del mundo. Se usa el mejor forecaster que tiene en el registro en un
 momento dado para predecir el precio futuro que a su vez lleva
 a la decisión del buy/sell.</p>
 <p>La estructura de los agentes esta formada por varias clases. BFParams es una clase que
 guarda valores de los parámetros por BFagents, y BFCast es donde se guardan los forecasters.
 BFCast, a su vez, guarda su bits de las condiciones en la subclase
 llamado BitVector.</p>

 <p>Si usted profundiza en el código de este agente, encontrará una cosa
 confusa. Este código y artículos basados en él usan el término "bit" para
 referirse a algo que puede valer
 0, 1, o 2. "0 significa no importa", 1 significa "NO" y 2 significa "SÍ." La confusión está
 en que se necesitan dos bits para representar esta cantidad de información.</p>
 <p>En el binario, los valores sería {00,01,10}, respectivamente, pero teniendo esto claro no hay problema.
 En cualquier caso en el código, como comentario, estan desarrollados varios puntos a tener en cuanta para seguir
 el funcionamiento de la clase </p>
 



<p><img src="../img/diag.jpg" width="757" height="428"></p>
<p>Copyright: </p>
 <p>Depto.Organización Industrial. Universidad de Valladolid</p>
<P>
<DL>
<DT><B>Version: </B><DD>1.0</DD>
<DT><B>Author: </B><DD>José Manuel Galán & Luis R. Izquierdo</DD>
</DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.LinkedList</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#activeList">activeList</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Una lista enlazada de Java, ( en la versión de Objective-C es un Swarm array) que mantiene los forecast activos</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#avspecificity">avspecificity</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;specificity media de los forecasters activos</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#currentTime">currentTime</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;El agente verifica regularmente Swarm para ver qué hora es</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#divisor">divisor</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coeficiente usado para calcular la demanda de acciones. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.LinkedList</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#fcastList">fcastList</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Una lista enlazada de Java, ( en la versión de Objective-C es un Swarm array) que mantiene los forecast que el agente usa</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#forecast">forecast</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;predicción del precio de la acción:(trialprice+dividend)*pdcoeff + offset.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#gacount">gacount</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¿Cuántas veces se ha utilizado el algoritmo genético?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#global_mean">global_mean</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;price+dividend</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#lastgatime">lastgatime</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Último periodo de tiempo en el que funciono el algoritmo genético</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#lforecast">lforecast</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valor del forecast del periodo anterior</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#minstrength">minstrength</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#offset">offset</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coeficiente usado en la prediciión del precio de la acción, recalculado en cada periodo en prepareForTrading</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.LinkedList</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#oldActiveList">oldActiveList</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Una lista enlazada de Java, ( en la versión de Objective-C es un Swarm array) que mantiene los forecast que el agente usó en el periodo anterior</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;<A HREF="../asm/BFParams.html">BFParams</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#params">params</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copia de cada agente de los parámetros</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#pdcoeff">pdcoeff</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coeficiente usado en la prediciión del precio de la acción, recalculado en cada periodo en prepareForTrading</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../asm/BFParams.html">BFParams</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#privateParams">privateParams</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;El objeto BFParams mantiene los parámetros del objeto</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#realDeviation">realDeviation</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ftarget-lforecast: ¿Cómo de lejos estuvo la predicción del agente</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#variance">variance</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Una media móvil exponencial con pesos de la varianza histórica del agente: combina la varianza anterior con la desviación al cuadrado:bv*variance + av*deviation*deviation</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#WEIGHTED">WEIGHTED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../asm/World.html">World</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#worldForAgent">worldForAgent</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copia del mundo para cada agente</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_asm.Agent"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Fields inherited from class asm.<A HREF="../asm/Agent.html">Agent</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../asm/Agent.html#cash">cash</A>, <A HREF="../asm/Agent.html#demand">demand</A>, <A HREF="../asm/Agent.html#dividend">dividend</A>, <A HREF="../asm/Agent.html#initialcash">initialcash</A>, <A HREF="../asm/Agent.html#intrate">intrate</A>, <A HREF="../asm/Agent.html#intratep1">intratep1</A>, <A HREF="../asm/Agent.html#mincash">mincash</A>, <A HREF="../asm/Agent.html#minholding">minholding</A>, <A HREF="../asm/Agent.html#myID">myID</A>, <A HREF="../asm/Agent.html#position">position</A>, <A HREF="../asm/Agent.html#price">price</A>, <A HREF="../asm/Agent.html#profit">profit</A>, <A HREF="../asm/Agent.html#wealth">wealth</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private)</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#BFagent(swarm.defobj.Zone)">BFagent</A></B>(swarm.defobj.Zone&nbsp;aZone)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#changeIntToBoolean(int)">changeIntToBoolean</A></B>(int&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Función auxiliar que hemos creado para pasar de un entero aun valor boolean,
 ya que en Java sólo se entienden estos en expresiones lógicas</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../asm/BitVector.html">BitVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#collectWorldData(swarm.defobj.Zone)">collectWorldData</A></B>(swarm.defobj.Zone&nbsp;aZone)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Un forecast tiene una serie de condiciones a las que mira. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#copyList$To(java.util.LinkedList, java.util.LinkedList)">copyList$To</A></B>(java.util.LinkedList&nbsp;list,
            java.util.LinkedList&nbsp;outputList)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Método implemetado para copiar de una lista enlazada de JAVA a otra</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../asm/BFCast.html">BFCast</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#CopyRule$From(asm.BFCast, asm.BFCast)">CopyRule$From</A></B>(<A HREF="../asm/BFCast.html">BFCast</A>&nbsp;to,
              <A HREF="../asm/BFCast.html">BFCast</A>&nbsp;from)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Este es un método que copia las variables de instancia de un objeto forecast
 a otro. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../asm/BFCast.html">BFCast</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#createNewForecast()">createNewForecast</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Crea una nueva forecast ( instancia de BFCast), con todos los bits de condición
 puestos a 00, significando "no importa". </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../asm/BFCast.html">BFCast</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#Crossover$Parent1$Parent2(asm.BFCast, asm.BFCast, asm.BFCast)">Crossover$Parent1$Parent2</A></B>(<A HREF="../asm/BFCast.html">BFCast</A>&nbsp;newForecast,
                          <A HREF="../asm/BFCast.html">BFCast</A>&nbsp;parent1,
                          <A HREF="../asm/BFCast.html">BFCast</A>&nbsp;parent2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Crossover

 en los bits de condición, Crossover() utiliza un crossover uniforme, cada bit
 es elegido aleatoriamente de un padre u otro.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#drand()">drand</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Método implementado para obtener nºs aleatorios uniformes[0,1]</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#feedForward()">feedForward</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Actualmente no hace nada, sólo se usa en ANNagentes ( basados en redes neuronales)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#Generalize$AvgStrength(java.util.LinkedList, double)">Generalize$AvgStrength</A></B>(java.util.LinkedList&nbsp;list,
                       double&nbsp;avgstrength)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generalize

 Generalize busca reglas que no han sido empleadas durante "longtime" y las
 hace más generales cambiando aleatoriamente 0´s y 1´s a "no importa". </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#getDemandAndSlope$forPrice(double, double)">getDemandAndSlope$forPrice</A></B>(double&nbsp;slope,
                           double&nbsp;trialprice)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Devuelve la demanda ( si > 0) u oferta (si < 0) usando la "mejor" forecast
 elegida en -prepareForTrading. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#getDeviation()">getDeviation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Devuelve el valor absoluto de realDeviation</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#getInputValues()">getInputValues</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Actualmente no hace nada, sólo se usa en ANNagentes ( basados en redes neuronales)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../asm/BFCast.html">BFCast</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#GetMort$Rejects(asm.BFCast, java.util.LinkedList)">GetMort$Rejects</A></B>(<A HREF="../asm/BFCast.html">BFCast</A>&nbsp;new2,
                java.util.LinkedList&nbsp;rejects)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetMort() selecciona uno de las forecast más débiles de npool para reemplazar
 con una nueva regla generada. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#getRealForecast()">getRealForecast</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Devuelve el forecast del agente</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#init()">init</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Es vital configurar los valores en la clase de los forecast, BFCast, el cual a
 su vez inicializa la clase BitVector</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#initForecasts()">initForecasts</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Crea los Objetos BFCast (forecast) y los pone en la lista llamada fCastList.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#irand(int)">irand</A></B>(int&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Método implementado para obtener nºs aleatorios uniformes[0,x-1]</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#lastgatime()">lastgatime</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Devuelve la última vez que se uso el Algoritmo Genético</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#MakePool$From(java.util.LinkedList, java.util.LinkedList)">MakePool$From</A></B>(java.util.LinkedList&nbsp;rejects,
              java.util.LinkedList&nbsp;list)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dada una lista de forecasts, encuentra las peores y las pone en el grupo de rechazables.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#Mutate$Status(asm.BFCast, boolean)">Mutate$Status</A></B>(<A HREF="../asm/BFCast.html">BFCast</A>&nbsp;new2,
              boolean&nbsp;changed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mutate

 Para los bits de condición, Mutate() mira cada bit con probabilidad pmutation.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#nbits()">nbits</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Devuelve "condbits" de parameters: el número de bits de condición que son
 monitorizados en world o 0 si no hay ninguno</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#nrules()">nrules</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Devuelve el nº de forecasts que estan siendo usados.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#performGA()">performGA</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hace funcionar el Algoritmo Genético.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#prepareForTrading()">prepareForTrading</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prepara una nueva lista activa de los forecast activos del agente, y calcula
 los coeficientes pdcoeff y offset en la ecuación
      forecast = pdcoeff*(trialprice+dividend) + offset

 La lista activa de todos los forecast que coinciden con las presentes condiciones
 es salvada para posteriores actualizaciones</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#setBFParameterObject(asm.BFParams)">setBFParameterObject</A></B>(<A HREF="../asm/BFParams.html">BFParams</A>&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Este método le dice a BFagentes donde mirar para conseguir los parámetros
 por defecto. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#setConditionsRandomly(asm.BFCast)">setConditionsRandomly</A></B>(<A HREF="../asm/BFCast.html">BFCast</A>&nbsp;fcastObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coge un objeto forecast y aleatoriamente cambia los bits que lo componen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../asm/BFCast.html">BFCast</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#Tournament(java.util.LinkedList)">Tournament</A></B>(java.util.LinkedList&nbsp;list)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tournament</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#TransferFcastsFrom$To$Replace(java.util.LinkedList, java.util.LinkedList, java.util.LinkedList)">TransferFcastsFrom$To$Replace</A></B>(java.util.LinkedList&nbsp;newList,
                              java.util.LinkedList&nbsp;forecastList,
                              java.util.LinkedList&nbsp;rejects)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TransferFcasts</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#updateActiveList(asm.BitVector)">updateActiveList</A></B>(<A HREF="../asm/BitVector.html">BitVector</A>&nbsp;worldvalues)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Este es el bucle principal al que sometemos a los forecasts. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#updatePerformance()">updatePerformance</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ahora actualizamos la varianza y la fuerza de todas las forecasts que
 estaban activas en el periodo anterior, ahora que sabemos como han funcionado.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#updateWeights()">updateWeights</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Actualmente no hace nada, sólo se usa en ANNagentes ( basados en redes neuronales)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../asm/BFagent.html#urand()">urand</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Método implementado para obtener nºs aleatorios uniformes[-1,1]</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_asm.Agent"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class asm.<A HREF="../asm/Agent.html">Agent</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../asm/Agent.html#constrainDemand(double, double)">constrainDemand</A>, <A HREF="../asm/Agent.html#creditEarningsAndPayTaxes()">creditEarningsAndPayTaxes</A>, <A HREF="../asm/Agent.html#getAgentPosition()">getAgentPosition</A>, <A HREF="../asm/Agent.html#getCash()">getCash</A>, <A HREF="../asm/Agent.html#getDividendFromWorld()">getDividendFromWorld</A>, <A HREF="../asm/Agent.html#getPriceFromWorld()">getPriceFromWorld</A>, <A HREF="../asm/Agent.html#getWealth()">getWealth</A>, <A HREF="../asm/Agent.html#setID(int)">setID</A>, <A HREF="../asm/Agent.html#setInitialCash(double)">setInitialCash</A>, <A HREF="../asm/Agent.html#setInitialHoldings()">setInitialHoldings</A>, <A HREF="../asm/Agent.html#setintrate(double)">setintrate</A>, <A HREF="../asm/Agent.html#setminHolding$minCash(double, double)">setminHolding$minCash</A>, <A HREF="../asm/Agent.html#setPosition(double)">setPosition</A>, <A HREF="../asm/Agent.html#setWorld(asm.World)">setWorld</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="currentTime"><!-- --></A><H3>
currentTime</H3>
<PRE>
public int <B>currentTime</B></PRE>
<DL>
<DD>El agente verifica regularmente Swarm para ver qué hora es</DL>
<HR>

<A NAME="lastgatime"><!-- --></A><H3>
lastgatime</H3>
<PRE>
public int <B>lastgatime</B></PRE>
<DL>
<DD>Último periodo de tiempo en el que funciono el algoritmo genético</DL>
<HR>

<A NAME="avspecificity"><!-- --></A><H3>
avspecificity</H3>
<PRE>
public double <B>avspecificity</B></PRE>
<DL>
<DD>specificity media de los forecasters activos</DL>
<HR>

<A NAME="forecast"><!-- --></A><H3>
forecast</H3>
<PRE>
public double <B>forecast</B></PRE>
<DL>
<DD>predicción del precio de la acción:(trialprice+dividend)*pdcoeff + offset.</DL>
<HR>

<A NAME="lforecast"><!-- --></A><H3>
lforecast</H3>
<PRE>
public double <B>lforecast</B></PRE>
<DL>
<DD>valor del forecast del periodo anterior</DL>
<HR>

<A NAME="global_mean"><!-- --></A><H3>
global_mean</H3>
<PRE>
public double <B>global_mean</B></PRE>
<DL>
<DD>price+dividend</DL>
<HR>

<A NAME="realDeviation"><!-- --></A><H3>
realDeviation</H3>
<PRE>
public double <B>realDeviation</B></PRE>
<DL>
<DD>ftarget-lforecast: ¿Cómo de lejos estuvo la predicción del agente</DL>
<HR>

<A NAME="variance"><!-- --></A><H3>
variance</H3>
<PRE>
public double <B>variance</B></PRE>
<DL>
<DD>Una media móvil exponencial con pesos de la varianza histórica del agente: combina la varianza anterior con la desviación al cuadrado:bv*variance + av*deviation*deviation</DL>
<HR>

<A NAME="pdcoeff"><!-- --></A><H3>
pdcoeff</H3>
<PRE>
public double <B>pdcoeff</B></PRE>
<DL>
<DD>Coeficiente usado en la prediciión del precio de la acción, recalculado en cada periodo en prepareForTrading</DL>
<HR>

<A NAME="offset"><!-- --></A><H3>
offset</H3>
<PRE>
public double <B>offset</B></PRE>
<DL>
<DD>Coeficiente usado en la prediciión del precio de la acción, recalculado en cada periodo en prepareForTrading</DL>
<HR>

<A NAME="divisor"><!-- --></A><H3>
divisor</H3>
<PRE>
public double <B>divisor</B></PRE>
<DL>
<DD>Coeficiente usado para calcular la demanda de acciones. Es proporcional a lambda y ala precisión de los forecasters</DL>
<HR>

<A NAME="gacount"><!-- --></A><H3>
gacount</H3>
<PRE>
public int <B>gacount</B></PRE>
<DL>
<DD>¿Cuántas veces se ha utilizado el algoritmo genético?</DL>
<HR>

<A NAME="privateParams"><!-- --></A><H3>
privateParams</H3>
<PRE>
public <A HREF="../asm/BFParams.html">BFParams</A> <B>privateParams</B></PRE>
<DL>
<DD>El objeto BFParams mantiene los parámetros del objeto</DL>
<HR>

<A NAME="fcastList"><!-- --></A><H3>
fcastList</H3>
<PRE>
public java.util.LinkedList <B>fcastList</B></PRE>
<DL>
<DD>Una lista enlazada de Java, ( en la versión de Objective-C es un Swarm array) que mantiene los forecast que el agente usa</DL>
<HR>

<A NAME="activeList"><!-- --></A><H3>
activeList</H3>
<PRE>
public java.util.LinkedList <B>activeList</B></PRE>
<DL>
<DD>Una lista enlazada de Java, ( en la versión de Objective-C es un Swarm array) que mantiene los forecast activos</DL>
<HR>

<A NAME="oldActiveList"><!-- --></A><H3>
oldActiveList</H3>
<PRE>
public java.util.LinkedList <B>oldActiveList</B></PRE>
<DL>
<DD>Una lista enlazada de Java, ( en la versión de Objective-C es un Swarm array) que mantiene los forecast que el agente usó en el periodo anterior</DL>
<HR>

<A NAME="worldForAgent"><!-- --></A><H3>
worldForAgent</H3>
<PRE>
public <A HREF="../asm/World.html">World</A> <B>worldForAgent</B></PRE>
<DL>
<DD>Copia del mundo para cada agente</DL>
<HR>

<A NAME="WEIGHTED"><!-- --></A><H3>
WEIGHTED</H3>
<PRE>
public final double <B>WEIGHTED</B></PRE>
<DL>
</DL>
<HR>

<A NAME="params"><!-- --></A><H3>
params</H3>
<PRE>
static <A HREF="../asm/BFParams.html">BFParams</A> <B>params</B></PRE>
<DL>
<DD>Copia de cada agente de los parámetros</DL>
<HR>

<A NAME="minstrength"><!-- --></A><H3>
minstrength</H3>
<PRE>
static double <B>minstrength</B></PRE>
<DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="BFagent(swarm.defobj.Zone)"><!-- --></A><H3>
BFagent</H3>
<PRE>
<B>BFagent</B>(swarm.defobj.Zone&nbsp;aZone)</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="drand()"><!-- --></A><H3>
drand</H3>
<PRE>
public final double <B>drand</B>()</PRE>
<DL>
<DD>Método implementado para obtener nºs aleatorios uniformes[0,1]<DD><DL>
<DT><B>Returns:</B><DD>double</DL>
</DD>
</DL>
<HR>

<A NAME="urand()"><!-- --></A><H3>
urand</H3>
<PRE>
public final double <B>urand</B>()</PRE>
<DL>
<DD>Método implementado para obtener nºs aleatorios uniformes[-1,1]<DD><DL>
<DT><B>Returns:</B><DD>double</DL>
</DD>
</DL>
<HR>

<A NAME="irand(int)"><!-- --></A><H3>
irand</H3>
<PRE>
public int <B>irand</B>(int&nbsp;x)</PRE>
<DL>
<DD>Método implementado para obtener nºs aleatorios uniformes[0,x-1]<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - &nbsp;<DT><B>Returns:</B><DD>double</DL>
</DD>
</DL>
<HR>

<A NAME="setBFParameterObject(asm.BFParams)"><!-- --></A><H3>
setBFParameterObject</H3>
<PRE>
public static void <B>setBFParameterObject</B>(<A HREF="../asm/BFParams.html">BFParams</A>&nbsp;x)</PRE>
<DL>
<DD>Este método le dice a BFagentes donde mirar para conseguir los parámetros
 por defecto. Debe dar al agente un objeto de la clase BFParams<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - &nbsp;</DL>
</DD>
</DL>
<HR>

<A NAME="init()"><!-- --></A><H3>
init</H3>
<PRE>
public static void <B>init</B>()</PRE>
<DL>
<DD>Es vital configurar los valores en la clase de los forecast, BFCast, el cual a
 su vez inicializa la clase BitVector</DL>
<HR>

<A NAME="initForecasts()"><!-- --></A><H3>
initForecasts</H3>
<PRE>
public java.lang.Object <B>initForecasts</B>()</PRE>
<DL>
<DD>Crea los Objetos BFCast (forecast) y los pone en la lista llamada fCastList.
 Este es el punto principal de la funcionalidad del agente, ya que son continuamente
 actualizados, mejorados y probados. Conviene notar que cada agente tiene una copia
 de los parámetros llamada privateParams. Esto podría ser usado para individualizar los
 parámetros en versiones posteriores.<DD><DL>
<DT><B>Returns:</B><DD>this</DL>
</DD>
</DL>
<HR>

<A NAME="createNewForecast()"><!-- --></A><H3>
createNewForecast</H3>
<PRE>
public <A HREF="../asm/BFCast.html">BFCast</A> <B>createNewForecast</B>()</PRE>
<DL>
<DD>Crea una nueva forecast ( instancia de BFCast), con todos los bits de condición
 puestos a 00, significando "no importa". Tambien configura el resto de los valores
 de los coeficientes dentro de BFCast. A este método se accede desde varios puntos dentro
 de BFagent.<DD><DL>
<DT><B>Returns:</B><DD>aForecast</DL>
</DD>
</DL>
<HR>

<A NAME="setConditionsRandomly(asm.BFCast)"><!-- --></A><H3>
setConditionsRandomly</H3>
<PRE>
public java.lang.Object <B>setConditionsRandomly</B>(<A HREF="../asm/BFCast.html">BFCast</A>&nbsp;fcastObject)</PRE>
<DL>
<DD>Coge un objeto forecast y aleatoriamente cambia los bits que lo componen.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fcastObject</CODE> - &nbsp;<DT><B>Returns:</B><DD>this</DL>
</DD>
</DL>
<HR>

<A NAME="prepareForTrading()"><!-- --></A><H3>
prepareForTrading</H3>
<PRE>
public java.lang.Object <B>prepareForTrading</B>()</PRE>
<DL>
<DD>Prepara una nueva lista activa de los forecast activos del agente, y calcula
 los coeficientes pdcoeff y offset en la ecuación
      forecast = pdcoeff*(trialprice+dividend) + offset

 La lista activa de todos los forecast que coinciden con las presentes condiciones
 es salvada para posteriores actualizaciones<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../asm/Agent.html#prepareForTrading()">prepareForTrading</A></CODE> in class <CODE><A HREF="../asm/Agent.html">Agent</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>this</DL>
</DD>
</DL>
<HR>

<A NAME="collectWorldData(swarm.defobj.Zone)"><!-- --></A><H3>
collectWorldData</H3>
<PRE>
public <A HREF="../asm/BitVector.html">BitVector</A> <B>collectWorldData</B>(swarm.defobj.Zone&nbsp;aZone)</PRE>
<DL>
<DD>Un forecast tiene una serie de condiciones a las que mira. Estas se almacenan en
 un BitVector. Necesitamos poner los datos del mundo de la misma manera para poder
 comparar fácilmente. Para chequear más rápidamente las condiciones, creamos entonces un BitVector
 donde almacenamos las condiciones del mundo que estan siendo monitorizadas. Esto requiere
 asumir como condición de diseño que todos los forecast de los agentes han de tener la misma
 lista de bits<DD><DL>
<DT><B>Parameters:</B><DD><CODE>aZone</CODE> - &nbsp;<DT><B>Returns:</B><DD>world</DL>
</DD>
</DL>
<HR>

<A NAME="changeIntToBoolean(int)"><!-- --></A><H3>
changeIntToBoolean</H3>
<PRE>
public boolean <B>changeIntToBoolean</B>(int&nbsp;a)</PRE>
<DL>
<DD>Función auxiliar que hemos creado para pasar de un entero aun valor boolean,
 ya que en Java sólo se entienden estos en expresiones lógicas<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - valor entero<DT><B>Returns:</B><DD>boolean</DL>
</DD>
</DL>
<HR>

<A NAME="updateActiveList(asm.BitVector)"><!-- --></A><H3>
updateActiveList</H3>
<PRE>
public java.lang.Object <B>updateActiveList</B>(<A HREF="../asm/BitVector.html">BitVector</A>&nbsp;worldvalues)</PRE>
<DL>
<DD>Este es el bucle principal al que sometemos a los forecasts. Vamos a
 través de los forecasts, comparandolos con las del mundo. Aquí al
 principio del bucle comprobamos como de grande es el bitvector (condwords).<DD><DL>
<DT><B>Parameters:</B><DD><CODE>worldvalues</CODE> - &nbsp;<DT><B>Returns:</B><DD>this</DL>
</DD>
</DL>
<HR>

<A NAME="getInputValues()"><!-- --></A><H3>
getInputValues</H3>
<PRE>
public java.lang.Object <B>getInputValues</B>()</PRE>
<DL>
<DD>Actualmente no hace nada, sólo se usa en ANNagentes ( basados en redes neuronales)<DD><DL>
<DT><B>Returns:</B><DD>this</DL>
</DD>
</DL>
<HR>

<A NAME="feedForward()"><!-- --></A><H3>
feedForward</H3>
<PRE>
public java.lang.Object <B>feedForward</B>()</PRE>
<DL>
<DD>Actualmente no hace nada, sólo se usa en ANNagentes ( basados en redes neuronales)<DD><DL>
<DT><B>Returns:</B><DD>this</DL>
</DD>
</DL>
<HR>

<A NAME="getDemandAndSlope$forPrice(double, double)"><!-- --></A><H3>
getDemandAndSlope$forPrice</H3>
<PRE>
public double <B>getDemandAndSlope$forPrice</B>(double&nbsp;slope,
                                         double&nbsp;trialprice)</PRE>
<DL>
<DD>Devuelve la demanda ( si > 0) u oferta (si < 0) usando la "mejor" forecast
 elegida en -prepareForTrading. Este valor es dado así:
 forecast = pdcoeff*(trialprice+dividend) + offset
 donde pdcoeff y offset también son dados en -prepareForTrading.
 También calculamos "slope" como la pendiente de la función de demanda
 resultante.( sin más que derivar la función de demanda)<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../asm/Agent.html#getDemandAndSlope$forPrice(double, double)">getDemandAndSlope$forPrice</A></CODE> in class <CODE><A HREF="../asm/Agent.html">Agent</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>slope</CODE> - &nbsp;<DD><CODE>trialprice</CODE> - &nbsp;<DT><B>Returns:</B><DD>demand</DL>
</DD>
</DL>
<HR>

<A NAME="getRealForecast()"><!-- --></A><H3>
getRealForecast</H3>
<PRE>
public double <B>getRealForecast</B>()</PRE>
<DL>
<DD>Devuelve el forecast del agente<DD><DL>
<DT><B>Returns:</B><DD>forecast</DL>
</DD>
</DL>
<HR>

<A NAME="updatePerformance()"><!-- --></A><H3>
updatePerformance</H3>
<PRE>
public java.lang.Object <B>updatePerformance</B>()</PRE>
<DL>
<DD>Ahora actualizamos la varianza y la fuerza de todas las forecasts que
 estaban activas en el periodo anterior, ahora que sabemos como han funcionado.
 Este método actualiza la información del precio y del dividendo del mundo. Mide
 lo lejos que estuvo la previsión de la realidad, y actualiza la varianza del
 forecast. Aquí se actualiza la varianza( mediante media movil exponencial con pesos)
  de cada uno de los forecasts de la active list. En el código hay una
  descripción de como se halla la strength de cada forecast.<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../asm/Agent.html#updatePerformance()">updatePerformance</A></CODE> in class <CODE><A HREF="../asm/Agent.html">Agent</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>this</DL>
</DD>
</DL>
<HR>

<A NAME="getDeviation()"><!-- --></A><H3>
getDeviation</H3>
<PRE>
public double <B>getDeviation</B>()</PRE>
<DL>
<DD>Devuelve el valor absoluto de realDeviation<DD><DL>
<DT><B>Returns:</B><DD>double</DL>
</DD>
</DL>
<HR>

<A NAME="updateWeights()"><!-- --></A><H3>
updateWeights</H3>
<PRE>
public java.lang.Object <B>updateWeights</B>()</PRE>
<DL>
<DD>Actualmente no hace nada, sólo se usa en ANNagentes ( basados en redes neuronales)<DD><DL>
<DT><B>Returns:</B><DD>this</DL>
</DD>
</DL>
<HR>

<A NAME="nbits()"><!-- --></A><H3>
nbits</H3>
<PRE>
public int <B>nbits</B>()</PRE>
<DL>
<DD>Devuelve "condbits" de parameters: el número de bits de condición que son
 monitorizados en world o 0 si no hay ninguno<DD><DL>
<DT><B>Returns:</B><DD>int</DL>
</DD>
</DL>
<HR>

<A NAME="nrules()"><!-- --></A><H3>
nrules</H3>
<PRE>
public int <B>nrules</B>()</PRE>
<DL>
<DD>Devuelve el nº de forecasts que estan siendo usados.<DD><DL>
<DT><B>Returns:</B><DD>numfcasts</DL>
</DD>
</DL>
<HR>

<A NAME="lastgatime()"><!-- --></A><H3>
lastgatime</H3>
<PRE>
public int <B>lastgatime</B>()</PRE>
<DL>
<DD>Devuelve la última vez que se uso el Algoritmo Genético<DD><DL>
<DT><B>Returns:</B><DD>lastgatime</DL>
</DD>
</DL>
<HR>

<A NAME="performGA()"><!-- --></A><H3>
performGA</H3>
<PRE>
public java.lang.Object <B>performGA</B>()</PRE>
<DL>
<DD>Hace funcionar el Algoritmo Genético.
 Se basa en los siguientes métodos:

 1. MakePool hace una lista de las forecast más débiles: rejectList. Son las
 "npool" reglas más débiles

 2. Se crean "nnew" nuevas reglas. Estas son puestas en la lista llamada newList.
 Sus configuraciones de bits son tomadas mediante "crossover" (cruce) usando
 selección por torneo de sus padres o mediante mutación.
 Ver los métodos Crossover y Mutate para más detalles de fincionamiento.

 3. Las nnew nuevas reglas reemplazan a las más viejas que cogimos en el paso 1.
 Esto se hace mediante el método "TransferFcastsFrom:To:" En este método, no se tiene
 en cuenta la "strength" para eliminar forecast si no que se eligen dos candicatos de
 rejectList aleatoriamente y se elige aquel con una cadena de bits mas parecida a la
 nnew que va a reemplazar. esto mantiene una mayor diversidad de reglas.

 4. Generalize busca reglas que no han sido empleadas durante "longtime" y las
 hace más generales cambiando aleatoriamente 0´s y 1´s a "no importa". Esto se hace
 independientemente de la fuerza y para todas las reglas.

 Los métodos que se encargan de este trabajo son los siguientes:

 public  BFCast CopyRule$From( BFCast to , BFCast from)
 public void MakePool$From (LinkedList rejects , LinkedList list)
 public boolean Mutate$Status (BFCast new2 , boolean changed)
 public BFCast Crossover$Parent1$Parent2( BFCast newForecast , BFCast parent1 , BFCast parent2)
 public void TransferFcastsFrom$To$Replace( LinkedList newList , LinkedList forecastList , LinkedList rejects)
 public BFCast GetMort$Rejects( BFCast new2 , LinkedList rejects)
 public void Generalize$AvgStrength( LinkedList list , double avgstrength)

 Lista de parámetros:

 npool--Tamaño del grupo de reglas más débiles con posibilidades de ser reemplazadas;
        Se especifica como una fracción de numfcasts mediante el parámetro "poolfrac"
 nnew --Número de nuevas reglas producidas.
         Se especifica como una fracción de numfcasts mediante el parámetro "newfrac"
 pcrossover--probabilidad de funcionamiento de Crossover
 plinear-- linear combination "crossover" prob.
 prandom-- random from each parent crossover prob.
 pmutation  -- per bit mutation prob.
 plong      -- long jump prob.
 pshort     -- short (neighborhood) jump prob.
 nhood      -- size of neighborhood
 longtime	-- generalize si la regla no se ha utilizado durante este tiempo
 genfrac	-- fracción de 0/1 que se pasan a "no importa" en generalize<DD><DL>
<DT><B>Returns:</B><DD>this</DL>
</DD>
</DL>
<HR>

<A NAME="CopyRule$From(asm.BFCast, asm.BFCast)"><!-- --></A><H3>
CopyRule$From</H3>
<PRE>
public <A HREF="../asm/BFCast.html">BFCast</A> <B>CopyRule$From</B>(<A HREF="../asm/BFCast.html">BFCast</A>&nbsp;to,
                            <A HREF="../asm/BFCast.html">BFCast</A>&nbsp;from)</PRE>
<DL>
<DD>Este es un método que copia las variables de instancia de un objeto forecast
 a otro. No se copia sólamente el bitvector, si no también la fuerza, la varianza
 specFactor, especificidad....<DD><DL>
<DT><B>Parameters:</B><DD><CODE>to</CODE> - &nbsp;<DD><CODE>from</CODE> - &nbsp;<DT><B>Returns:</B><DD>BFCast</DL>
</DD>
</DL>
<HR>

<A NAME="MakePool$From(java.util.LinkedList, java.util.LinkedList)"><!-- --></A><H3>
MakePool$From</H3>
<PRE>
public void <B>MakePool$From</B>(java.util.LinkedList&nbsp;rejects,
                          java.util.LinkedList&nbsp;list)</PRE>
<DL>
<DD>Dada una lista de forecasts, encuentra las peores y las pone en el grupo de rechazables.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rejects</CODE> - &nbsp;<DD><CODE>list</CODE> - &nbsp;</DL>
</DD>
</DL>
<HR>

<A NAME="Tournament(java.util.LinkedList)"><!-- --></A><H3>
Tournament</H3>
<PRE>
public <A HREF="../asm/BFCast.html">BFCast</A> <B>Tournament</B>(java.util.LinkedList&nbsp;list)</PRE>
<DL>
<DD>Tournament<DD><DL>
<DT><B>Parameters:</B><DD><CODE>list</CODE> - &nbsp;<DT><B>Returns:</B><DD>BFCast</DL>
</DD>
</DL>
<HR>

<A NAME="Mutate$Status(asm.BFCast, boolean)"><!-- --></A><H3>
Mutate$Status</H3>
<PRE>
public boolean <B>Mutate$Status</B>(<A HREF="../asm/BFCast.html">BFCast</A>&nbsp;new2,
                             boolean&nbsp;changed)</PRE>
<DL>
<DD>Mutate

 Para los bits de condición, Mutate() mira cada bit con probabilidad pmutation.
 Si se cambia, se hace con las siguientes probabilidades:
    0  ->  * with probability 2/3, 1 with probability 1/3
    1  ->  * with probability 2/3, 0 with probability 1/3
    *  ->  0 with probability 1/3, 1 with probability 1/3,
           unchanged with probability 1/3
 POSIBILIDAD DE CONFUSION:los valores cambian así:

 0      1    1/3          2       1/3
 1      0    2/3          2       1/3
 2      0    2/3          1       1/3

 Para los parámetros de predicción, Mutate() debe de hacer una de estas dos cosas,
 independientemente de los parámetros.
 1. "Long jump": el parámetro es elegido aletoriamente entre min-max range
 2. "Short jump": el parámetro es elegido aletoriamente entre una distribución uniforme
 de rango oldvalue-nhood*range a oldvalue+nhood*range, donde range = max-min.
 El método 1 se ejecuta con probabilidad plong, el método 2 con probabilidad
 pshort, y se dejan los parámetros sin cambiar con probabilidad 1-plong-pshort.

 Se devuelve YES si se han producidos cambios, y NO si no se han producido.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>new2</CODE> - &nbsp;<DD><CODE>changed</CODE> - &nbsp;<DT><B>Returns:</B><DD>boolean</DL>
</DD>
</DL>
<HR>

<A NAME="Crossover$Parent1$Parent2(asm.BFCast, asm.BFCast, asm.BFCast)"><!-- --></A><H3>
Crossover$Parent1$Parent2</H3>
<PRE>
public <A HREF="../asm/BFCast.html">BFCast</A> <B>Crossover$Parent1$Parent2</B>(<A HREF="../asm/BFCast.html">BFCast</A>&nbsp;newForecast,
                                        <A HREF="../asm/BFCast.html">BFCast</A>&nbsp;parent1,
                                        <A HREF="../asm/BFCast.html">BFCast</A>&nbsp;parent2)</PRE>
<DL>
<DD>Crossover

 en los bits de condición, Crossover() utiliza un crossover uniforme, cada bit
 es elegido aleatoriamente de un padre u otro.
 Para los parámetros de predicción, Crossover() hace una de estas tres cosas:
 1. Elige una combianción lineal de los parámetros de los padres con pesos según
 strength
 2. Elige cada parámetro aleatoriamente de cada padre
 3. Elige unos de los parámetros de uno de los padres ( o todos de uno o todos de otro)

 Se utiliza el método 1 con probabilidad plinear, método 2 con probabilidad
 prandom, método 3 con probabilidad 1-plinear-prandom.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>newForecast</CODE> - &nbsp;<DD><CODE>parent1</CODE> - &nbsp;<DD><CODE>parent2</CODE> - &nbsp;<DT><B>Returns:</B><DD>newForecast</DL>
</DD>
</DL>
<HR>

<A NAME="TransferFcastsFrom$To$Replace(java.util.LinkedList, java.util.LinkedList, java.util.LinkedList)"><!-- --></A><H3>
TransferFcastsFrom$To$Replace</H3>
<PRE>
public void <B>TransferFcastsFrom$To$Replace</B>(java.util.LinkedList&nbsp;newList,
                                          java.util.LinkedList&nbsp;forecastList,
                                          java.util.LinkedList&nbsp;rejects)</PRE>
<DL>
<DD>TransferFcasts<DD><DL>
<DT><B>Parameters:</B><DD><CODE>newList</CODE> - &nbsp;<DD><CODE>forecastList</CODE> - &nbsp;<DD><CODE>rejects</CODE> - &nbsp;</DL>
</DD>
</DL>
<HR>

<A NAME="GetMort$Rejects(asm.BFCast, java.util.LinkedList)"><!-- --></A><H3>
GetMort$Rejects</H3>
<PRE>
public <A HREF="../asm/BFCast.html">BFCast</A> <B>GetMort$Rejects</B>(<A HREF="../asm/BFCast.html">BFCast</A>&nbsp;new2,
                              java.util.LinkedList&nbsp;rejects)</PRE>
<DL>
<DD>GetMort() selecciona uno de las forecast más débiles de npool para reemplazar
 con una nueva regla generada. En este método, no se tiene
 en cuenta la "strength" para eliminar forecast si no que se eligen dos candicatos de
 rejectList aleatoriamente y se elige aquel con una cadena de bits mas parecida a la
 nnew que va a reemplazar. Esto mantiene una mayor diversidad de reglas.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>new2</CODE> - &nbsp;<DD><CODE>rejects</CODE> - &nbsp;<DT><B>Returns:</B><DD>aReject</DL>
</DD>
</DL>
<HR>

<A NAME="Generalize$AvgStrength(java.util.LinkedList, double)"><!-- --></A><H3>
Generalize$AvgStrength</H3>
<PRE>
public void <B>Generalize$AvgStrength</B>(java.util.LinkedList&nbsp;list,
                                   double&nbsp;avgstrength)</PRE>
<DL>
<DD>Generalize

 Generalize busca reglas que no han sido empleadas durante "longtime" y las
 hace más generales cambiando aleatoriamente 0´s y 1´s a "no importa". Esto se hace
 independientemente de la fuerza y para todas las reglas.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>list</CODE> - &nbsp;<DD><CODE>avgstrength</CODE> - &nbsp;</DL>
</DD>
</DL>
<HR>

<A NAME="copyList$To(java.util.LinkedList, java.util.LinkedList)"><!-- --></A><H3>
copyList$To</H3>
<PRE>
public java.lang.Object <B>copyList$To</B>(java.util.LinkedList&nbsp;list,
                                    java.util.LinkedList&nbsp;outputList)</PRE>
<DL>
<DD>Método implemetado para copiar de una lista enlazada de JAVA a otra<DD><DL>
<DT><B>Parameters:</B><DD><CODE>list</CODE> - &nbsp;<DD><CODE>outputList</CODE> - &nbsp;<DT><B>Returns:</B><DD>this</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/BFagent.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../asm/BarChart.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../asm/BFCast.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="BFagent.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
